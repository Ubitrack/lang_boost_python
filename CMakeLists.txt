cmake_minimum_required(VERSION 2.8)

SET(PROJECT_NAME "ubitrack_python")

PROJECT(${PROJECT_NAME})

# Add a cache variable PREFER_STATIC_LIBRARIES to have the choice of generating a project
# linking against static libraries if they exist. Default is NO since most people will not use this.
IF( NOT DEFINED PREFER_STATIC_LIBRARIES )
  SET( PREFER_STATIC_LIBRARIES "NO" CACHE BOOL "Decides if CMake should prefer static libraries to dynamic libraries when both exist." )
  MARK_AS_ADVANCED(PREFER_STATIC_LIBRARIES)
ENDIF( NOT DEFINED PREFER_STATIC_LIBRARIES )

IF( PREFER_STATIC_LIBRARIES )
  SET( CMAKE_FIND_LIBRARY_SUFFIXES .a;${CMAKE_FIND_LIBRARY_SUFFIXES} )
ENDIF( PREFER_STATIC_LIBRARIES )

SET( ${PROJECT_NAME}_COMPILE_FLAGS "-D${PROJECT_NAME}_EXPORTS" )
SET( ${PROJECT_NAME}_SOURCE_DIR ${${PROJECT_NAME}_SOURCE_DIR} )

INCLUDE( "${${PROJECT_NAME}_SOURCE_DIR}/SourceFiles.txt" )

SET(${PROJECT_NAME}_SRCS ${PROJECT_SRCS})
SET(${PROJECT_NAME}_HEADERS ${PROJECT_HEADERS})
SET(${PROJECT_NAME}_GENERATOR_SRCS ${PROJECT_GENERATOR_SRCS})

SET(optionalLibs)
SET(requiredLibs)

# Version of ${PROJECT_NAME}
SET( ${PROJECT_NAME}_MAJOR_VERSION 1 )
SET( ${PROJECT_NAME}_MINOR_VERSION 0 )
SET( ${PROJECT_NAME}_BUILD_VERSION 0 )

# enable g++ C++0x extensions
#IF(CMAKE_COMPILER_IS_GNUCXX)
#	SET(CMAKE_CXX_FLAGS ${CMAKE_CXX_FLAGS} "-std=gnu++0x")
#ENDIF(CMAKE_COMPILER_IS_GNUCXX)

# Needed to convert from \ to / on windows. Not needed in the FindModules since
# call to macro takes care of that there.
SET( CONVERTED_UBITRACK_PATH "" )
IF( EXISTS $ENV{UBITRACK_PATH} )
  FILE( TO_CMAKE_PATH $ENV{UBITRACK_PATH} CONVERTED_UBITRACK_PATH )
ENDIF( EXISTS $ENV{UBITRACK_PATH} )
SET(CMAKE_MODULE_PATH  ${${PROJECT_NAME}_SOURCE_DIR}/cmake ${CONVERTED_UBITRACK_PATH}/..share/UbiTrack/cmake)

MACRO(getenv_path VAR)
  SET(ENV_${VAR} $ENV{${VAR}})
  # replace won't work if var is blank
  IF(ENV_${VAR})
    FILE( TO_CMAKE_PATH ENV_${VAR} ${ENV_${VAR}} )
  ENDIF ()
ENDMACRO(getenv_path)

IF(X86_64)
  getenv_path(UBITRACKLIB_EXTERNAL64)
  IF(ENV_UBITRACKLIB_EXTERNAL64)
    SET(EXTERNAL_LIBRARIES_DIR "${ENV_UBITRACKLIB_EXTERNAL64}")
  ENDIF(ENV_UBITRACKLIB_EXTERNAL64)
ELSE()
  getenv_path(UBITRACKLIB_EXTERNAL32)
  IF(ENV_UBITRACKLIB_EXTERNAL32)
    SET(EXTERNAL_LIBRARIES_DIR "${ENV_UBITRACKLIB_EXTERNAL32}")
  ENDIF(ENV_UBITRACKLIB_EXTERNAL32)
ENDIF(X86_64)


# UbiTrack  
FIND_PACKAGE(Ubitrack REQUIRED)

IF(UBITRACK_FOUND)
  SET(HAVE_UBITRACK 1)
  INCLUDE_DIRECTORIES( ${UBITRACK_INCLUDE_DIR} )
  # currently needed because of relative include :(
  INCLUDE_DIRECTORIES( "${UBITRACK_INCLUDE_DIR}/utFacade" )
  SET(requiredLibs ${requiredLibs} ${UBITRACK_LIBRARIES} )
ENDIF(UBITRACK_FOUND)

IF(WIN32)
  set(${PROJECT_NAME}_COMPILE_FLAGS "${${PROJECT_NAME}_COMPILE_FLAGS} /EHsc /c /W3 /GR /wd4355 /wd4996 /wd4251 /wd4275 /wd4819 /wd4290")
  set(${PROJECT_NAME}_LINK_FLAGS "/SUBSYSTEM:CONSOLE")
  set(${PROJECT_NAME}_DEFINES "WIN32" "_MBCS" "_WIN32_WINNT=0x501")	
ENDIF(WIN32) 


# settings for 3rdparty libraries
ADD_DEFINITIONS(-DTIXML_USE_STL)
ADD_DEFINITIONS(-DHAVE_TINYXML)



# Find Boost library. Required to compile.
IF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)
	set(BOOST_ROOT_DIR "${EXTERNAL_LIBRARIES_DIR}/boost")
	INCLUDE_DIRECTORIES( ${Boost_INCLUDE_DIR} )
ENDIF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)


#Boost bindings
IF(CMAKE_COMPILER_IS_GNUCXX)
  add_definitions("-DBOOST_UBLAS_BOUNDED_ARRAY_ALIGN= __attribute__ ((aligned (16)))")
ENDIF(CMAKE_COMPILER_IS_GNUCXX)
ADD_DEFINITIONS(-DBOOST_SPIRIT_USE_OLD_NAMESPACE)

IF(MSVC)
  # force dynamic linking of boost libs on windows ..
  ADD_DEFINITIONS(-DBOOST_ALL_DYN_LINK)
ENDIF(MSVC)

SET(HAVE_BOOST 0)
set(Boost_USE_STATIC_LIBS   OFF)
set(Boost_USE_MULTITHREADED ON)
set(Boost_USE_STATIC_RUNTIME OFF)
FIND_PACKAGE( Boost 1.49 COMPONENTS thread date_time system filesystem regex chrono locale serialization program_options REQUIRED)
IF(Boost_FOUND)
  ADD_DEFINITIONS("-DBOOST_FILESYSTEM_VERSION=3")
  ADD_DEFINITIONS(-DHAVE_BOOST)
  SET(HAVE_BOOST 1)
    INCLUDE_DIRECTORIES( ${Boost_INCLUDE_DIR} )
    SET(requiredLibs ${requiredLibs} ${Boost_LIBRARIES} )
ENDIF(Boost_FOUND)

# Find Lapack library. Required to compile.
IF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)
  SET(LAPACK_ROOT_DIR "${EXTERNAL_LIBRARIES_DIR}/lapack")
ENDIF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)

SET(HAVE_LAPACK 0)
IF(WIN32)
  FIND_PACKAGE(LAPACK)
  IF(NOT LAPACK_FOUND AND DEFINED EXTERNAL_LIBRARIES_DIR)
    SET(LAPACK_LIB_DIR "${EXTERNAL_LIBRARIES_DIR}/lapack/lib")
    # for now just manually define the libraries ..
    SET(LAPACK_LIBRARIES "${LAPACK_LIB_DIR}/atlas.lib" 
	"${LAPACK_LIB_DIR}/cblas.lib" 
	"${LAPACK_LIB_DIR}/f77blas.lib"
	"${LAPACK_LIB_DIR}/g2c.lib"
	"${LAPACK_LIB_DIR}/gcc.lib"
	"${LAPACK_LIB_DIR}/lapack.lib"
	)
    SET(LAPACK_FOUND 1)
  ENDIF(NOT LAPACK_FOUND AND DEFINED EXTERNAL_LIBRARIES_DIR)
ELSE()
  FIND_PACKAGE(LAPACK REQUIRED)
ENDIF(WIN32)
IF(LAPACK_FOUND)
  ADD_DEFINITIONS(-DHAVE_LAPACK)
  SET(HAVE_LAPACK 1)
  INCLUDE_DIRECTORIES( ${LAPACK_INCLUDE_DIR} )
  SET(requiredLibs ${requiredLibs} ${LAPACK_LIBRARIES} )
ENDIF(LAPACK_FOUND)

#OpenCV 
IF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)
  SET(OPENCV_ROOT_DIR "${EXTERNAL_LIBRARIES_DIR}/opencv")
ENDIF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)

SET(HAVE_OPENCV 0)
FIND_PACKAGE(OpenCV)
IF(OPENCV_FOUND)
  MESSAGE(STATUS "Found: opencv, includes: ${OPENCV_INCLUDE_DIR}, libraries: ${OPENCV_LIBRARIES}")
  ADD_DEFINITIONS(-DHAVE_OPENCV)
  SET(HAVE_OPENCV 1)
  INCLUDE_DIRECTORIES( ${OPENCV_INCLUDE_DIR} )
  SET(requiredLibs ${requiredLibs} ${OPENCV_LIBRARIES} )
ENDIF(OPENCV_FOUND)

# TBB
# setup defaults for windows binary distributions
IF(WIN32)
  IF(MSVC71)
    SET(TBB_COMPILER "vc7.1")
  ENDIF(MSVC71)
  IF(MSVC80)
    SET(TBB_COMPILER "vc8")
  ENDIF(MSVC80)
  IF(MSVC90)
    SET(TBB_COMPILER "vc9")
  ENDIF(MSVC90)
  IF(MSVC10)
    sET(TBB_COMPILER "vc10")
  ENDIF(MSVC10)
  IF(X86_64)
    SET(TBB_ARCHITECTURE "intel64")
  ELSE()
    SET(TBB_ARCHITECTURE "ia32")
  ENDIF(X86_64)
ENDIF(WIN32)

IF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)
  SET(TBB_INSTALL_DIR "${EXTERNAL_LIBRARIES_DIR}/tbb")
ENDIF(WIN32 AND DEFINED EXTERNAL_LIBRARIES_DIR)

SET(HAVE_TBB 0)
FIND_PACKAGE(TBB)
IF(TBB_FOUND)
  ADD_DEFINITIONS(-DHAVE_TBB)
  SET(HAVE_TBB 1)
  INCLUDE_DIRECTORIES( ${TBB_INCLUDE_DIR} )
  SET(requiredLibs ${requiredLibs} ${TBB_LIBRARIES} )
ENDIF(TBB_FOUND)



find_package(Shiboken 1.2.0 REQUIRED)
#find_package(PySide 1.2.0 REQUIRED)


if (NOT SITE_PACKAGE)
    execute_process(
        COMMAND ${SHIBOKEN_PYTHON_INTERPRETER} -c "from distutils import sysconfig; \\
            print(sysconfig.get_python_lib(1,0,prefix='${CMAKE_INSTALL_PREFIX}'))"
        OUTPUT_VARIABLE SITE_PACKAGE
        OUTPUT_STRIP_TRAILING_WHITESPACE)
    if (NOT SITE_PACKAGE)
        message(FATAL_ERROR "Could not detect Python module installation directory.")
    elseif (APPLE)
        message(STATUS "!!! The generated bindings will be installed on ${SITE_PACKAGE}, is it right!?")
    endif()
endif()

#set(GENERATOR_EXTRA_FLAGS --generator-set=shiboken --enable-parent-ctor-heuristic --enable-pyside-extensions --enable-return-value-heuristic --use-isnull-as-nb_nonzero)
set(GENERATOR_EXTRA_FLAGS --generator-set=shiboken --enable-parent-ctor-heuristic --enable-return-value-heuristic --use-isnull-as-nb_nonzero)
if(WIN32 OR DEFINED AVOID_PROTECTED_HACK)
    message(STATUS "${PROJECT_NAME} will be generated avoiding the protected hack!")
    set(GENERATOR_EXTRA_FLAGS ${GENERATOR_EXTRA_FLAGS} --avoid-protected-hack)
    add_definitions(-DAVOID_PROTECTED_HACK)
else()
    message(STATUS "${PROJECT_NAME} will be generated using the protected hack!")
endif()

set(${PROJECT_NAME}_TYPESYSTEM
	${CMAKE_CURRENT_SOURCE_DIR}/src/typesystem_${PROJECT_NAME}.xml
)

configure_file("${CMAKE_CURRENT_SOURCE_DIR}/src/${PROJECT_NAME}-binding.txt.in"
               "${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-binding.txt" @ONLY)

add_custom_command(OUTPUT ${${PROJECT_NAME}_GENERATOR_SRCS}
COMMAND ${SHIBOKEN_BINARY} --project-file=${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-binding.txt ${GENERATOR_EXTRA_FLAGS}
DEPENDS ${${PROJECT_NAME}_TYPESYSTEM} ${CMAKE_CURRENT_SOURCE_DIR}/src/global.h
WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
COMMENT "Running generator for '${PROJECT_NAME}' binding..."
)

MESSAGE(STATUS "GENERATED FILES: ${${PROJECT_NAME}_GENERATOR_SRCS}")

include_directories(${CMAKE_CURRENT_SOURCE_DIR}
                    ${CMAKE_SOURCE_DIR}
                    ${SHIBOKEN_INCLUDE_DIR}
                    ${SHIBOKEN_PYTHON_INCLUDE_DIR})


# autogenerate ${PROJECT_NAME}.h depending on the libraries available.
#CONFIGURE_FILE( ${${PROJECT_NAME}_SOURCE_DIR}/../include/${PROJECT_NAME}/${PROJECT_NAME}.cmake ${${PROJECT_NAME}_SOURCE_DIR}/../include/${PROJECT_NAME}/${PROJECT_NAME}.h )

IF(MSVC)
  # Add the ${PROJECT_NAME}.rc resource file if Visual Studio
  #SET( ${PROJECT_NAME}_SRCS ${${PROJECT_NAME}_SRCS} ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.rc )
ENDIF(MSVC)

IF( COMMAND cmake_policy )
  IF( POLICY CMP0003 )
    CMAKE_POLICY(SET CMP0003 OLD)
  ENDIF( POLICY CMP0003 )
ENDIF( COMMAND cmake_policy )


ADD_LIBRARY(${PROJECT_NAME} MODULE ${${PROJECT_NAME}_GENERATOR_SRCS})


set_property(TARGET ${PROJECT_NAME} PROPERTY PREFIX "")

if(WIN32)
    set_property(TARGET ${PROJECT_NAME} PROPERTY SUFFIX ".pyd")
endif()

# make the name of debug libraries end in _d.
SET_TARGET_PROPERTIES( ${PROJECT_NAME} PROPERTIES DEBUG_POSTFIX "_d" )

IF(UNIX) 
  SET_TARGET_PROPERTIES( ${PROJECT_NAME} PROPERTIES OUTPUT_NAME ${PROJECT_NAME} )
ENDIF(UNIX)

TARGET_LINK_LIBRARIES( ${PROJECT_NAME} ${requiredLibs} ${optionalLibs} ${SHIBOKEN_PYTHON_LIBRARIES} ${SHIBOKEN_LIBRARY})

IF(MSVC)
  # Create variables
  SET( ${PROJECT_NAME}_LINK_FLAGS_DEBUG "" )
  
  SET( PROJECT_MSVC_VERSION 6 )
  SET( TEMP_MSVC_VERSION 1299 )
  WHILE( ${MSVC_VERSION} GREATER ${TEMP_MSVC_VERSION} )
    MATH( EXPR PROJECT_MSVC_VERSION "${PROJECT_MSVC_VERSION} + 1" )
    MATH( EXPR TEMP_MSVC_VERSION "${TEMP_MSVC_VERSION} + 100" )
  ENDWHILE( ${MSVC_VERSION} GREATER ${TEMP_MSVC_VERSION} )
  
  # Treat wchar_t as built in type for all visual studio versions.
  # This is default for every version above 7 ( so far ) but we still set it for all.
  SET( ${PROJECT_NAME}_COMPILE_FLAGS "${${PROJECT_NAME}_COMPILE_FLAGS} /Zc:wchar_t")
  
  IF( ${MSVC_VERSION} GREATER 1399 )
    # Remove compiler warnings about deprecation for visual studio versions 8 and above.
    SET( ${PROJECT_NAME}_COMPILE_FLAGS "${${PROJECT_NAME}_COMPILE_FLAGS} -D_CRT_SECURE_NO_DEPRECATE" )
  ENDIF( ${MSVC_VERSION} GREATER 1399 )

  IF( ${MSVC_VERSION} GREATER 1499 )
    # Build using several threads for visual studio versions 9 and above.
    SET( ${PROJECT_NAME}_COMPILE_FLAGS "${${PROJECT_NAME}_COMPILE_FLAGS} /MP" )
    # Remove link against default library for debug builds.
    SET( ${PROJECT_NAME}_LINK_FLAGS_DEBUG "${${PROJECT_NAME}_LINK_FLAGS_DEBUG} /NODEFAULTLIB:msvcrt" )
  ENDIF( ${MSVC_VERSION} GREATER 1499 )

  SET_TARGET_PROPERTIES( ${PROJECT_NAME} PROPERTIES OUTPUT_NAME ${PROJECT_NAME}_vc${PROJECT_MSVC_VERSION} )

  # Seems like ${PROJECT_NAME} needs to have incremental linking shut off for vc8. Since this is
  # not the most important feature it is shut off for all visual studio versions.
  SET_TARGET_PROPERTIES( ${PROJECT_NAME} PROPERTIES LINK_FLAGS_DEBUG "${${PROJECT_NAME}_LINK_FLAGS_DEBUG} /INCREMENTAL:NO" )

  # autogenerate ${PROJECT_NAME}.rc depending on the version
  #CONFIGURE_FILE( ${PROJECT_NAME}.rc.cmake ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.rc )
  
  #ADD_CUSTOM_COMMAND( TARGET ${PROJECT_NAME}
  #	PRE_BUILD
  #	COMMAND ${${PROJECT_NAME}_SOURCE_DIR}/UpdateResourceFile 
  #	ARGS ${PROJECT_NAME} ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}.rc ${${PROJECT_NAME}_SOURCE_DIR}/${PROJECT_NAME}.rc.cmake
  #	${${PROJECT_NAME}_MAJOR_VERSION} ${${PROJECT_NAME}_MINOR_VERSION}
  #	${${PROJECT_NAME}_BUILD_VERSION} "${${PROJECT_NAME}_SVN_VERSION}"
  #	"${PROJECT_NAME}_Output_Name"
  #	"$(TargetFileName)" )

ENDIF(MSVC)

SET( ${PROJECT_NAME}_FULL_VERSION ${${PROJECT_NAME}_MAJOR_VERSION}.${${PROJECT_NAME}_MINOR_VERSION}.${${PROJECT_NAME}_BUILD_VERSION} ) 
SET_TARGET_PROPERTIES( ${PROJECT_NAME} PROPERTIES VERSION ${${PROJECT_NAME}_FULL_VERSION} )

# set compile flags for ${PROJECT_NAME} project
SET_TARGET_PROPERTIES( ${PROJECT_NAME} PROPERTIES COMPILE_FLAGS "${${PROJECT_NAME}_COMPILE_FLAGS}" )

IF( UNIX )
# Install header files on non-windows system (e.g. Unix).
INSTALL( FILES ${${PROJECT_NAME}_HEADERS}
         DESTINATION include/${PROJECT_NAME} )
ENDIF( UNIX )

SET( DEFAULT_BIN_INSTALL "bin" )
SET( DEFAULT_LIB_INSTALL "lib" )

IF( WIN32 )
  SET( DEFAULT_BIN_INSTALL "bin32" )
  SET( DEFAULT_LIB_INSTALL "lib32" )
  IF( CMAKE_SIZEOF_VOID_P EQUAL 8 )
    SET( DEFAULT_BIN_INSTALL "bin64" )
    SET( DEFAULT_LIB_INSTALL "lib64" )
  ENDIF( CMAKE_SIZEOF_VOID_P EQUAL 8 )
ENDIF( WIN32 )

# Install directories.
INSTALL( TARGETS ${PROJECT_NAME}
         LIBRARY DESTINATION ${DEFAULT_LIB_INSTALL} COMPONENT ${PROJECT_NAME}_cpack_runtime
         RUNTIME DESTINATION ${DEFAULT_BIN_INSTALL} COMPONENT ${PROJECT_NAME}_cpack_runtime
         ARCHIVE DESTINATION ${DEFAULT_LIB_INSTALL} COMPONENT ${PROJECT_NAME}_cpack_libraries)

#INCLUDE ( ${${PROJECT_NAME}_SOURCE_DIR}/${PROJECT_NAME}CPack.cmake)
